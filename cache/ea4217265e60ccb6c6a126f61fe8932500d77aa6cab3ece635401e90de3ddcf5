{"children":[{"children":[],"uri":"https://www.notion.so/1fa75552ce7181fe85d0d3de57149b25","type":"bookmark","createdTime":1747841591660,"lastEditedTime":1747841591660,"link":"https://github.com/SantoshSrivatsan24/ece745","title":"GitHub - SantoshSrivatsan24/ece745: Verifiying a Wishbone to I2C Multiple Bus Controller using SystemVerilog","description":"Verifiying a Wishbone to I2C Multiple Bus Controller using SystemVerilog - GitHub - SantoshSrivatsan24/ece745: Verifiying a Wishbone to I2C Multiple Bus Controller using SystemVerilog","icon":"https://github.com/fluidicon.png","cover":"https://opengraph.githubassets.com/85465b976f0c03f901dfa9feb35b42cfd331b459ca0510b3228ea89d226eb697/SantoshSrivatsan24/ece745"},{"children":[],"uri":"https://www.notion.so/1fa75552ce7181b4a836c49d2ebea9bf","type":"text","createdTime":1747841591659,"lastEditedTime":1747841591659,"title":[]},{"children":[],"uri":"https://www.notion.so/1fa75552ce718178ad30ffa36560bc9e","type":"table_of_contents","color":"gray","createdTime":1747841591659,"lastEditedTime":1747841591659},{"children":[],"uri":"https://www.notion.so/1fa75552ce7181a39608f001af369f33","type":"heading","createdTime":1747841591660,"lastEditedTime":1747841591660,"title":[["Introduction"]],"depth":2},{"children":[],"uri":"https://www.notion.so/1fa75552ce7181ae802cc04014a41d76","type":"text","createdTime":1747841591660,"lastEditedTime":1747841591660,"title":[["The goal of this project was to design a SystemVerilog testbench around a Wishbone to I2C Multiple Bus Controller. i.e., A DUT that takes in a Wishbone command and produces an I2C signal. This is a project I worked on through the semester and it was divided into four phases."]]},{"children":[],"uri":"https://www.notion.so/1fa75552ce71813384f0e1c379bfde77","type":"heading","createdTime":1747841591660,"lastEditedTime":1747841591660,"title":[["Phase 1"]],"depth":2},{"children":[],"uri":"https://www.notion.so/1fa75552ce71813ea09de6f97622e041","type":"text","createdTime":1747841591659,"lastEditedTime":1747841591659,"title":[["We were provided with the DUT and a BFM for its wishbone side. The first step was to build a BFM that could understand the I2C protocol. This involved pouring over the I2C spec to learn how a data transfer took place. I had to learn how to detect "],["START",[["c",null]]],[", "],["STOP",[["c",null]]],[", "],["ACK",[["c",null]]],[", and "],["NACK",[["c",null]]],[" commands and how to piece them together to form a data transfer. "]]},{"children":[],"uri":"https://www.notion.so/1fa75552ce7181d88d05fd1026516200","type":"text","createdTime":1747841591659,"lastEditedTime":1747841591659,"title":[]},{"children":[],"uri":"https://www.notion.so/1fa75552ce7181e7b6f6dc0176fe445d","type":"text","createdTime":1747841591659,"lastEditedTime":1747841591659,"title":[["A write to the I2C slave begins with a "],["START",[["c",null]]],[" command followed by the slave address, the data, and a "],["STOP",[["c",null]]],[" command. The slave acknowledges ("],["ACK",[["c",null]]],["s) every byte of data sent from the master."]]},{"children":[],"uri":"https://www.notion.so/1fa75552ce7181278737cdd030c71cce","type":"text","createdTime":1747841591658,"lastEditedTime":1747841591658,"title":[]},{"children":[],"uri":"https://www.notion.so/1fa75552ce71819e83a0ddab45a343eb","type":"text","createdTime":1747841591660,"lastEditedTime":1747841591660,"title":[["A read from the I2C slave begins with a "],["START",[["c",null]]],[" command and is followed by the slave address. The master (DUT) then gives up the bus for the slave to drive with the data to be received (by the master)."]]},{"children":[],"uri":"https://www.notion.so/1fa75552ce71811ebb33eb095451bf7e","type":"text","createdTime":1747841591659,"lastEditedTime":1747841591659,"title":[]},{"children":[],"uri":"https://www.notion.so/1fa75552ce718148a3b5f73178fcf6b0","type":"text","createdTime":1747841591660,"lastEditedTime":1747841591660,"title":[["We tested the functionality of our BFM with a stream of continuous writes, reads, and alternating reads and writes."]]},{"children":[],"uri":"https://www.notion.so/1fa75552ce718196af91f618c627e72a","type":"heading","createdTime":1747841591659,"lastEditedTime":1747841591659,"title":[["Phase 2"]],"depth":2},{"children":[],"uri":"https://www.notion.so/1fa75552ce718126ab97f6e67ed1fe7a","type":"text","createdTime":1747841591659,"lastEditedTime":1747841591659,"title":[["Once we had a working I2C BFM, we had to construct a full testbench around the design. I started by drawing a block diagram of all the SV components to understand which blocks needed to communicate with each other. "]]},{"children":[],"uri":"https://www.notion.so/1fa75552ce71810f8b09c8fd2292903d","type":"text","createdTime":1747841591659,"lastEditedTime":1747841591659,"title":[]},{"children":[],"uri":"https://www.notion.so/1fa75552ce7181c6b47befdd33bdd792","type":"text","createdTime":1747841591659,"lastEditedTime":1747841591659,"title":[["The BFM which was previously driven from the top-level testbench is now controlled by the Driver and Monitor.  The Driver and Monitor are encapsulated into an Agent - a single component to handle the transaction level abstraction for our I2C protocol. The Agent forwards transactions from the Monitor to a Scoreboard which in turn receives ‚Äúgolden‚Äù transactions from a Predictor. The Agents for each protocol (Wishbone and I2C) along with the Predictor and Scoreboard make up the Environment for our testbench. The Environment is largely a component for analyzing transactions and is separate from the Generator which stimulates the design. The testbench also includes a Configuration component for the design. "]]},{"children":[],"uri":"https://www.notion.so/1fa75552ce7181729ffbf90701b041e7","type":"callout","color":"yellow_background","createdTime":1747841591659,"lastEditedTime":1747841591659,"icon":"üóíÔ∏è","title":[["- If the Configuration is in the environment, we‚Äôve entangled the two. We can‚Äôt randomize the configuration structure first.\n- An example configuration could be whether the DUT operates with or without interrupts enabled."]]},{"children":[],"uri":"https://www.notion.so/1fa75552ce718178a5e2cddf399f872a","type":"image","createdTime":1747841591659,"lastEditedTime":1747841630060,"source":"https://www.notion.so/signed/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F759af34e-dffa-4cd0-9da7-08e911d8cdf0%2Fa0fccd31-7153-4030-bda9-f80e1ff7301d%2FUntitled.png?width=790.96875&table=block&id=1fa75552-ce71-8178-a5e2-cddf399f872a","caption":[["Fig. 1: Reusable layered testbench"]],"width":790.96875,"height":-1,"fullWidth":false,"pageWidth":true,"aspectRatio":0.43857634902411025,"preserveScale":true},{"children":[],"uri":"https://www.notion.so/1fa75552ce7181e5a028d16804a8a5fb","type":"text","createdTime":1747841591660,"lastEditedTime":1747841591660,"title":[]},{"children":[],"uri":"https://www.notion.so/1fa75552ce718162a0d4c5789628df8f","type":"text","createdTime":1747841591660,"lastEditedTime":1747841591660,"title":[["With all these blocks, I had to decide when it was appropriate to use a blocking or non-blocking method to connect them. For instance, the Driver interfaces with the BFM through blocking methods "],["bl_put",[["c",null]]],[" and "],["bl_get",[["c",null]]],[". But the Monitor can send transactions to its Agent through a "],["nb_put",[["c",null]]],[". Likewise, the Predictor/golden model can send transactions to the Scoreboard using a "],["nb_put",[["c",null]]],["."]]},{"children":[],"uri":"https://www.notion.so/1fa75552ce718181a029ea92a37d6114","type":"text","createdTime":1747841591660,"lastEditedTime":1747841591660,"title":[]},{"children":[],"uri":"https://www.notion.so/1fa75552ce71811da9c4dd4125bd7fb2","type":"text","createdTime":1747841591660,"lastEditedTime":1747841591660,"title":[["The predictor was the hardest component to implement as it models the byte-level FSM in the DUT. It receives Wishbone commands from the Wishbone monitor and updates its internal state. Once it receives a Wishbone "],["STOP",[["c",null]]],[" command, it constructs an I2C transaction that it "],["transports",[["i",null]]],[" to the Scoreboard for checking."]]},{"children":[],"uri":"https://www.notion.so/1fa75552ce7181d38cfaf3e1c385c1d6","type":"text","createdTime":1747841591659,"lastEditedTime":1747841591659,"title":[]},{"children":[],"uri":"https://www.notion.so/1fa75552ce718199ae8dc66f9e374328","type":"image","createdTime":1747841591660,"lastEditedTime":1747841591660,"source":"https://www.notion.so/signed/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F759af34e-dffa-4cd0-9da7-08e911d8cdf0%2F452bb690-94df-4e79-845a-3b63fddd3bfa%2FUntitled.png?width=501&table=block&id=1fa75552-ce71-8199-ae8d-c66f9e374328","caption":[["Fig. 2: Byte-level FSM in the DUT"]],"width":501,"height":463,"fullWidth":false,"pageWidth":false,"aspectRatio":0.9241516966067864,"preserveScale":true},{"children":[],"uri":"https://www.notion.so/1fa75552ce7181b3bcbeda05a6edd3ca","type":"heading","createdTime":1747841591660,"lastEditedTime":1747841591660,"title":[["Phase 3"]],"depth":2},{"children":[],"uri":"https://www.notion.so/1fa75552ce7181cf950dcdc1824877b9","type":"text","createdTime":1747841591659,"lastEditedTime":1747841591659,"title":[["The next step in verifying our design was coming up with a test plan. My testplan included:"]]},{"children":[{"children":[],"uri":"https://www.notion.so/1fa75552ce7181e19a0ff93e1ea458b6","type":"bulleted_list","createdTime":1747841591662,"lastEditedTime":1747841591662,"title":[["Checking the default value for every register"]]},{"children":[],"uri":"https://www.notion.so/1fa75552ce7181f880aaeffd82cf705d","type":"bulleted_list","createdTime":1747841591662,"lastEditedTime":1747841591662,"title":[["Reading from and writing to every register"]]},{"children":[],"uri":"https://www.notion.so/1fa75552ce7181a9ad28f945704f5eca","type":"bulleted_list","createdTime":1747841591662,"lastEditedTime":1747841591662,"title":[["Ensuring that read-only registers can‚Äôt be written to"]]},{"children":[],"uri":"https://www.notion.so/1fa75552ce7181149939fc470861a602","type":"bulleted_list","createdTime":1747841591662,"lastEditedTime":1747841591662,"title":[["Ensuring that a write to one register doesn‚Äôt affect another"]]}],"uri":"https://www.notion.so/1fa75552ce7181ddbed7c7122ef38b35","type":"bulleted_list","createdTime":1747841591659,"lastEditedTime":1747841591659,"title":[["Directed tests such as:"]]},{"children":[{"children":[],"uri":"https://www.notion.so/1fa75552ce71815594c3c626c0d6ca9b","type":"bulleted_list","createdTime":1747841591663,"lastEditedTime":1747841591663,"title":[["Ensuring the IRQ signal stays low when interrupts are disabled"]]},{"children":[],"uri":"https://www.notion.so/1fa75552ce7181b3a459d134bf3aa661","type":"bulleted_list","createdTime":1747841591663,"lastEditedTime":1747841591663,"title":[["Making sure the IRQ signal goes high when a command completes"]]},{"children":[],"uri":"https://www.notion.so/1fa75552ce7181bf90d4d66f5590d6bc","type":"bulleted_list","createdTime":1747841591663,"lastEditedTime":1747841591663,"title":[["Making sure the status bits ("],["DON",[["c",null]]],[", "],["NAK",[["c",null]]],[", "],["AL",[["c",null]]],[", "],["ERR",[["c",null]]],[") bits are 0 during command execution and only one of them is set when a command completes."]]}],"uri":"https://www.notion.so/1fa75552ce7181afb52bdeebf642bcda","type":"bulleted_list","createdTime":1747841591659,"lastEditedTime":1747841591659,"title":[["Functionality tests such as:"]]},{"children":[{"children":[],"uri":"https://www.notion.so/1fa75552ce7181eea490da9bba9a5c8d","type":"bulleted_list","createdTime":1747841591663,"lastEditedTime":1747841591663,"title":[["Making sure that every byte and bit-level state is covered"]]},{"children":[],"uri":"https://www.notion.so/1fa75552ce718177b7bec47b40e01d02","type":"bulleted_list","createdTime":1747841591663,"lastEditedTime":1747841591663,"title":[["Making sure the two FSMs never reach an invalid state"]]}],"uri":"https://www.notion.so/1fa75552ce7181bab025f506b7437fd1","type":"bulleted_list","createdTime":1747841591660,"lastEditedTime":1747841591660,"title":[["Coverage tests such as:"]]},{"children":[],"uri":"https://www.notion.so/1fa75552ce718157a3efd03068f2fa30","type":"bulleted_list","createdTime":1747841591660,"lastEditedTime":1747841591660,"title":[["RTL code coverage"]]},{"children":[],"uri":"https://www.notion.so/1fa75552ce71810181a4fa5a01c926c9","type":"heading","createdTime":1747841591658,"lastEditedTime":1747841591658,"title":[["Phase 4"]],"depth":2},{"children":[],"uri":"https://www.notion.so/1fa75552ce7181c087a2c9abb06b0534","type":"text","createdTime":1747841591659,"lastEditedTime":1747841591659,"title":[["I implemented the stimulus for various parts of the test plan in classes inherited from the base Generator class. A derived object of the Generator class is created at runtime using an "],["object factory",[["i",null]]],[". "]]},{"children":[],"uri":"https://www.notion.so/1fa75552ce71815584c3c471075ac251","type":"text","createdTime":1747841591659,"lastEditedTime":1747841591659,"title":[]},{"children":[],"uri":"https://www.notion.so/1fa75552ce718159adabd60afe8b51b5","type":"text","createdTime":1747841591658,"lastEditedTime":1747841591658,"title":[["The status bits ("],["DON",[["c",null]]],[", "],["NAK",[["c",null]]],[", "],["AL",[["c",null]]],[", "],["ERR",[["c",null]]],[") are internal to the design and aren‚Äôt visible when the DUT is viewed as a black box. To verify the correct operation of such internal signals, I created a probe interface that I "],["bound",[["i",null]]],[" to a block inside the design. I verified some features using SystemVerilog Assertions (SVA) in the probe interface."]]},{"children":[],"uri":"https://www.notion.so/1fa75552ce7181bb8be5d1c9b85731be","type":"text","createdTime":1747841591658,"lastEditedTime":1747841591658,"title":[]},{"children":[],"uri":"https://www.notion.so/1fa75552ce71810d8e3cd5054fb5191f","type":"text","createdTime":1747841591659,"lastEditedTime":1747841591659,"title":[["I used a SV construct "],["randsequence",[["c",null]]],[" to generate Wishbone transactions in a random but meaningful order to try and hit as many FSM states as I could."]]},{"children":[],"uri":"https://www.notion.so/1fa75552ce71811489cdf4f8d6f1d169","type":"divider","createdTime":1747841591659,"lastEditedTime":1747841591659},{"children":[],"uri":"https://www.notion.so/1fa75552ce7181cda4dbe8263bb9f31a","type":"text","createdTime":1747841591660,"lastEditedTime":1747841591660,"title":[]},{"children":[],"uri":"https://www.notion.so/1fa75552ce7181e5a636cbd62909d48b","type":"text","createdTime":1747841591659,"lastEditedTime":1747841591659,"title":[]}],"uri":"https://www.notion.so/1fa75552ce718103a40cd08de0681bbf","type":"page","createdTime":1747841591658,"lastEditedTime":1747841591658,"title":[["Verifying an I2C Multiple Bus Controller using SystemVerilog"]],"icon":"üõ†Ô∏è","fullWidth":false,"coverPosition":1,"properties":{"!`\"w":[["Yes"]],"'2]%":[["ece745"]],":H`m":[["Yes"]],"C'lP":[["No"]],"{iD?":[["Design Verification,ECE 745"]],"|Ay0":[["post"]]}}